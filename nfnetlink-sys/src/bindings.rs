/* automatically generated by rust-bindgen */

pub const NLM_F_REQUEST: u32 = 1;
pub const NLM_F_MULTI: u32 = 2;
pub const NLM_F_ACK: u32 = 4;
pub const NLM_F_ECHO: u32 = 8;
pub const NLM_F_DUMP_INTR: u32 = 16;
pub const NLM_F_DUMP_FILTERED: u32 = 32;
pub const NLM_F_ROOT: u32 = 256;
pub const NLM_F_MATCH: u32 = 512;
pub const NLM_F_ATOMIC: u32 = 1024;
pub const NLM_F_DUMP: u32 = 768;
pub const NLM_F_REPLACE: u32 = 256;
pub const NLM_F_EXCL: u32 = 512;
pub const NLM_F_CREATE: u32 = 1024;
pub const NLM_F_APPEND: u32 = 2048;
pub const NLMSG_ALIGNTO: u32 = 4;
pub const NL_MMAP_MSG_ALIGNMENT: u32 = 4;
pub const NLA_F_NESTED: u32 = 32768;
pub const NLA_F_NET_BYTEORDER: u32 = 16384;
pub const NLA_TYPE_MASK: i32 = -49153;
pub const NLA_ALIGNTO: u32 = 4;
pub const NF_NETLINK_CONNTRACK_NEW: u32 = 1;
pub const NF_NETLINK_CONNTRACK_UPDATE: u32 = 2;
pub const NF_NETLINK_CONNTRACK_DESTROY: u32 = 4;
pub const NF_NETLINK_CONNTRACK_EXP_NEW: u32 = 8;
pub const NF_NETLINK_CONNTRACK_EXP_UPDATE: u32 = 16;
pub const NF_NETLINK_CONNTRACK_EXP_DESTROY: u32 = 32;
pub const NFNL_NFA_NEST: u32 = 32768;
pub const NFA_ALIGNTO: u32 = 4;
pub const NFNETLINK_V0: u32 = 0;
pub const NFNL_SUBSYS_NONE: u32 = 0;
pub const NFNL_SUBSYS_CTNETLINK: u32 = 1;
pub const NFNL_SUBSYS_CTNETLINK_EXP: u32 = 2;
pub const NFNL_SUBSYS_QUEUE: u32 = 3;
pub const NFNL_SUBSYS_ULOG: u32 = 4;
pub const NFNL_SUBSYS_COUNT: u32 = 5;
pub const NETLINK_BROADCAST_SEND_ERROR: u32 = 4;
pub const NFNL_BUFFSIZE: u32 = 8192;

pub const NETLINK_UNCONNECTED: u32 = 0;
pub const NETLINK_CONNECTED: u32 = 1;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nfattr {
    pub nfa_len: u16,
    pub nfa_type: u16,
}

#[test]
fn bindgen_test_layout_nfattr() {
    assert_eq!(
        ::std::mem::size_of::<nfattr>(),
        4usize,
        concat!("Size of: ", stringify!(nfattr))
    );
    assert_eq!(
        ::std::mem::align_of::<nfattr>(),
        2usize,
        concat!("Alignment of ", stringify!(nfattr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nfattr>())).nfa_len as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nfattr),
            "::",
            stringify!(nfa_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nfattr>())).nfa_type as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(nfattr),
            "::",
            stringify!(nfa_type)
        )
    );
}
pub const nfnetlink_groups_NFNLGRP_NONE: nfnetlink_groups = 0;
pub const nfnetlink_groups_NFNLGRP_CONNTRACK_NEW: nfnetlink_groups = 1;
pub const nfnetlink_groups_NFNLGRP_CONNTRACK_UPDATE: nfnetlink_groups = 2;
pub const nfnetlink_groups_NFNLGRP_CONNTRACK_DESTROY: nfnetlink_groups = 3;
pub const nfnetlink_groups_NFNLGRP_CONNTRACK_EXP_NEW: nfnetlink_groups = 4;
pub const nfnetlink_groups_NFNLGRP_CONNTRACK_EXP_UPDATE: nfnetlink_groups = 5;
pub const nfnetlink_groups_NFNLGRP_CONNTRACK_EXP_DESTROY: nfnetlink_groups = 6;
pub const nfnetlink_groups___NFNLGRP_MAX: nfnetlink_groups = 7;
pub type nfnetlink_groups = u32;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nfgenmsg {
    /// AF_xxx
    pub nfgen_family: u8,
    /// nfnetlink version
    pub version: u8,
    /// resource ID (Big endian)
    pub res_id: u16,
}
#[test]
fn bindgen_test_layout_nfgenmsg() {
    assert_eq!(
        ::std::mem::size_of::<nfgenmsg>(),
        4usize,
        concat!("Size of: ", stringify!(nfgenmsg))
    );
    assert_eq!(
        ::std::mem::align_of::<nfgenmsg>(),
        2usize,
        concat!("Alignment of ", stringify!(nfgenmsg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nfgenmsg>())).nfgen_family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nfgenmsg),
            "::",
            stringify!(nfgen_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nfgenmsg>())).version as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(nfgenmsg),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nfgenmsg>())).res_id as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(nfgenmsg),
            "::",
            stringify!(res_id)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nfnlhdr {
    pub nlh: nlmsghdr,
    pub nfmsg: nfgenmsg,
}
#[test]
fn bindgen_test_layout_nfnlhdr() {
    assert_eq!(
        ::std::mem::size_of::<nfnlhdr>(),
        20usize,
        concat!("Size of: ", stringify!(nfnlhdr))
    );
    assert_eq!(
        ::std::mem::align_of::<nfnlhdr>(),
        4usize,
        concat!("Alignment of ", stringify!(nfnlhdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nfnlhdr>())).nlh as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nfnlhdr),
            "::",
            stringify!(nlh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nfnlhdr>())).nfmsg as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nfnlhdr),
            "::",
            stringify!(nfmsg)
        )
    );
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nfnl_callback {
    pub call: ::std::option::Option<
        unsafe extern "C" fn(
            nlh: *mut nlmsghdr,
            nfa: *mut *mut nfattr,
            data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub data: *mut ::std::os::raw::c_void,
    pub attr_count: u16,
}
#[test]
fn bindgen_test_layout_nfnl_callback() {
    assert_eq!(
        ::std::mem::size_of::<nfnl_callback>(),
        24usize,
        concat!("Size of: ", stringify!(nfnl_callback))
    );
    assert_eq!(
        ::std::mem::align_of::<nfnl_callback>(),
        8usize,
        concat!("Alignment of ", stringify!(nfnl_callback))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nfnl_callback>())).call as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nfnl_callback),
            "::",
            stringify!(call)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nfnl_callback>())).data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nfnl_callback),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nfnl_callback>())).attr_count as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nfnl_callback),
            "::",
            stringify!(attr_count)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nfnl_handle {
    _unused: [u8; 0],
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nfnl_subsys_handle {
    _unused: [u8; 0],
}

extern "C" {
    pub fn nfnl_fd(h: *mut nfnl_handle) -> ::std::os::raw::c_int;
    pub fn nfnl_portid(h: *const nfnl_handle) -> ::std::os::raw::c_uint;
    pub fn nfnl_open() -> *mut nfnl_handle;
    pub fn nfnl_close(arg1: *mut nfnl_handle) -> ::std::os::raw::c_int;
    pub fn nfnl_subsys_open(
        arg1: *mut nfnl_handle,
        arg2: u8,
        arg3: u8,
        arg4: ::std::os::raw::c_uint,
    ) -> *mut nfnl_subsys_handle;
    pub fn nfnl_subsys_close(arg1: *mut nfnl_subsys_handle);
    pub fn nfnl_set_sequence_tracking(h: *mut nfnl_handle);
    pub fn nfnl_unset_sequence_tracking(h: *mut nfnl_handle);
    pub fn nfnl_set_rcv_buffer_size(h: *mut nfnl_handle, size: ::std::os::raw::c_uint);
    pub fn nfnl_send(arg1: *mut nfnl_handle, arg2: *mut nlmsghdr) -> ::std::os::raw::c_int;
    pub fn nfnl_sendmsg(
        arg1: *const nfnl_handle,
        msg: *const msghdr,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
    pub fn nfnl_sendiov(
        nfnlh: *const nfnl_handle,
        iov: *const iovec,
        num: ::std::os::raw::c_uint,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
    pub fn nfnl_fill_hdr(
        arg1: *mut nfnl_subsys_handle,
        arg2: *mut nlmsghdr,
        arg3: ::std::os::raw::c_uint,
        arg4: u8,
        arg5: u16,
        arg6: u16,
        arg7: u16,
    );
    pub fn nfnl_talk(
        arg1: *mut nfnl_handle,
        arg2: *mut nlmsghdr,
        arg3: pid_t,
        arg4: ::std::os::raw::c_uint,
        arg5: *mut nlmsghdr,
        arg6: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut sockaddr_nl,
                arg2: *mut nlmsghdr,
                arg3: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        arg7: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
    pub fn nfnl_listen(
        arg1: *mut nfnl_handle,
        arg2: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut sockaddr_nl,
                arg2: *mut nlmsghdr,
                arg3: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        arg3: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
    pub fn nfnl_recv(h: *const nfnl_handle, buf: *mut ::std::os::raw::c_uchar, len: usize)
        -> isize;
    pub fn nfnl_callback_register(
        arg1: *mut nfnl_subsys_handle,
        type_: u8,
        cb: *mut nfnl_callback,
    ) -> ::std::os::raw::c_int;
    pub fn nfnl_callback_unregister(
        arg1: *mut nfnl_subsys_handle,
        type_: u8,
    ) -> ::std::os::raw::c_int;
    pub fn nfnl_handle_packet(
        arg1: *mut nfnl_handle,
        buf: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn nfnl_parse_hdr(
        nfnlh: *const nfnl_handle,
        nlh: *const nlmsghdr,
        genmsg: *mut *mut nfgenmsg,
    ) -> *mut nfattr;
    pub fn nfnl_check_attributes(
        nfnlh: *const nfnl_handle,
        nlh: *const nlmsghdr,
        tb: *mut *mut nfattr,
    ) -> ::std::os::raw::c_int;
    pub fn nfnl_get_msg_first(
        h: *mut nfnl_handle,
        buf: *const ::std::os::raw::c_uchar,
        len: usize,
    ) -> *mut nlmsghdr;
    pub fn nfnl_get_msg_next(
        h: *mut nfnl_handle,
        buf: *const ::std::os::raw::c_uchar,
        len: usize,
    ) -> *mut nlmsghdr;
}

/// Callback verdict
pub const NFNL_CB_FAILURE: i32 = -1;
/// Callback verdict
pub const NFNL_CB_STOP: i32 = 0;
/// Callback verdict
pub const NFNL_CB_CONTINUE: i32 = 1;

extern "C" {
    pub fn nfnl_join(
        nfnlh: *const nfnl_handle,
        group: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
    pub fn nfnl_process(
        h: *mut nfnl_handle,
        buf: *const ::std::os::raw::c_uchar,
        len: usize,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nfnl_iterator {
    _unused: [u8; 0],
}

extern "C" {
    pub fn nfnl_iterator_create(
        h: *const nfnl_handle,
        buf: *const ::std::os::raw::c_char,
        len: usize,
    ) -> *mut nfnl_iterator;
    pub fn nfnl_iterator_destroy(it: *mut nfnl_iterator);
    pub fn nfnl_iterator_process(
        h: *mut nfnl_handle,
        it: *mut nfnl_iterator,
    ) -> ::std::os::raw::c_int;
    pub fn nfnl_iterator_next(
        h: *const nfnl_handle,
        it: *mut nfnl_iterator,
    ) -> ::std::os::raw::c_int;
    pub fn nfnl_catch(h: *mut nfnl_handle) -> ::std::os::raw::c_int;
    pub fn nfnl_query(h: *mut nfnl_handle, nlh: *mut nlmsghdr) -> ::std::os::raw::c_int;
    pub fn nfnl_addattr_l(
        arg1: *mut nlmsghdr,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_void,
        arg5: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn nfnl_addattr8(
        arg1: *mut nlmsghdr,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: u8,
    ) -> ::std::os::raw::c_int;
    pub fn nfnl_addattr16(
        arg1: *mut nlmsghdr,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: u16,
    ) -> ::std::os::raw::c_int;
    pub fn nfnl_addattr32(
        arg1: *mut nlmsghdr,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: u32,
    ) -> ::std::os::raw::c_int;
    pub fn nfnl_nfa_addattr_l(
        arg1: *mut nfattr,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_void,
        arg5: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn nfnl_nfa_addattr16(
        arg1: *mut nfattr,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: u16,
    ) -> ::std::os::raw::c_int;
    pub fn nfnl_nfa_addattr32(
        arg1: *mut nfattr,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: u32,
    ) -> ::std::os::raw::c_int;
    pub fn nfnl_parse_attr(
        arg1: *mut *mut nfattr,
        arg2: ::std::os::raw::c_int,
        arg3: *mut nfattr,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn nfnl_build_nfa_iovec(
        iov: *mut iovec,
        nfa: *mut nfattr,
        type_: u16,
        len: u32,
        val: *mut ::std::os::raw::c_uchar,
    );
    pub fn nfnl_rcvbufsiz(
        h: *const nfnl_handle,
        size: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
    pub fn nfnl_dump_packet(
        arg1: *mut nlmsghdr,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_char,
    );
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nlif_handle {
    _unused: [u8; 0],
}

extern "C" {
    pub fn nlif_open() -> *mut nlif_handle;
    pub fn nlif_close(orig: *mut nlif_handle);
    pub fn nlif_fd(nlif_handle: *mut nlif_handle) -> ::std::os::raw::c_int;
    pub fn nlif_query(nlif_handle: *mut nlif_handle) -> ::std::os::raw::c_int;
    pub fn nlif_catch(nlif_handle: *mut nlif_handle) -> ::std::os::raw::c_int;
    pub fn nlif_index2name(
        nlif_handle: *mut nlif_handle,
        if_index: ::std::os::raw::c_uint,
        name: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
    pub fn nlif_get_ifflags(
        h: *const nlif_handle,
        index: ::std::os::raw::c_uint,
        flags: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
